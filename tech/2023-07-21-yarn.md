---
layout: post
title: What it takes to migrate a monorepo from node_modules to PnP
categories: tech
date: 2023-07-21
---

A lot:

- updating shared dependencies
- explicitly defining dependencies
- unifying on a single version of webpack
- gulp??
- fixing tests
- making all those changes and not causing downtime for developers

----------------------------------------------------------------------------------------

## Preface

I didn't know anything about frontend build systems prior to this project. All I knew
was a few people had tried making this happen, but it was clearly not a trivial effort
and would require an engineer's full focus. I fought to prioritize it due to the
performance gains promised on the other side of the fence; they couldn't be ignored much
longer, for the sake of all the melting intel MacBooks.

## Getting started

It all started with a mesage in the Yarn discord:

> szehnder â€” 08/12/2022 9:38 AM ðŸ‘‹ hello! I'm currently working on migrating a monorepo
> over to using PnP (using yarn v3 fyi). The [Hybrid PnP + node_modules mono-repo](
> https://yarnpkg.com/getting-started/recipes/#hybrid-pnp--node_modules-mono-repo)
> recipe is helpful, but I'm wondering if there is a recommended path for a hybrid
> approach where PnP is opt-in, rather than the other way around like the above recipe
> suggests. Thanks in advance!

## The gameplan

I didn't hear back, so I had to do some thinking about how to go about doing this
without causing downtime for our devs. If PnP can't be opt-in, then the switch to PnP
will need to happen in one fell swoop, which is much easier said than done! This is what
I came up with:

> szehnder â€” 08/29/2022 11:56 AM After some searching, it seems like there isn't strong
> support for linking PnP-based packages to node-modules-based packages, which makes
> sense. I have instead opted to do the following, in case it helps anyone else:
>
> - switch .yarnrc.yml over to nodeLinker:pnp
> - attempt to yarn install and subsequently build atomic components within the monorepo
>   with PnP
> - after making necessary tweaks to successfully build, switch back to nodeLinker:
>   node-modules and yarn install and build with the changes I made for PnP, just to
>   verfy it works in node-modules world as well
> - put up a diff for the atomic component, not adding .pnp.cjs and keeping the
>   nodeLinker as node-modules
>
> once all of these piecemeal changes have been made and committed, I'll commit the
> nodeLinker:pnp change and the .pnp.cjs file, and we should ideally be able to make a
> somewhat painless switch over to PnP
>
> I have written a helper script that toggles my environment between one that uses
> .pnp.cjs and node_modules/, so i am not spending a ton of time waiting for either to
> repopulate when switching my nodeLinker between the two

Thinking more about this now, I don't know if it makes sense to not support
cross-linking PnP- and node_modules-backed packages. Knowing more about the system now,
it doesn't seem like there would be any technical limitation to allowing this type of
behavior, other than maybe some performance hit when trying to resolve packages in both
systems. But anyway...

The process outlined above really did end up being the main workflow for handling the
migration -- run my `pnp-toggle` script, try and build a package, resolve failures that
pop up through a myriad of different fixes, once it built with PnP, run `pnp-toggle` and
try and build it with node_modules to see if it still worked. Then, merge the changes
_without_ switching the repo over to PnP as the nodeLinker. Devs didn't notice any
difference, the only thing affected was my MacBook's CPU[0].

## The experience

need to get it done quick since new stuff slips in all the time


----------------------------------------------------------------------------------------

Have others gone through a similar migration? Did you do things differently that
resulted in a less painful process? I'm curious to know what others ran into when doing

----------------------------------------------------------------------------------------

[0](#0): By the end of this effort, my MacBook CPU was legitimately cooked. Things
started breaking in very weird ways, and diagnostics at the Genius Bar reported back
that it had seen sustained high temperature events very frequently. 8 hours of
compilation a day can do that I guess.
